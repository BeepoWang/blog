---
title: JS 基础知识
date: '2022-06-04'
tags:
  - javascript
---

## 数据类型

1. 分类

- 基本类型（值）

  - string
  - number
  - boolean
  - null
  - undefined
  - symbol
  - bigint

- 对象类型（引用）

  - object

2. 判断

- typeof 不能判断 null 和 object object 和 array
- instanceof
- Object.prototype.toString.call()

3. null 和 undefined

- undefined 定义未赋值
- null 定义并赋值为 null

4. 变量类型和数据类型

- 变量类型（变量内存值得类型）
  - 基本类型：保存基本类型的数据
  - 引用类型：保存地址值
- 数据类型
  - 基本类型
  - 对象类型

## 数据 变量 内存

1. 数据

- 存储在内存中代表特定信息的值
- 数据可传递、可运算

2. 内存

- 内存条通电后产生的可存储数据的空间（临时）
- 内存条 ===> 通电 ==> 产生内存空间 ===> 存储数据 ===> 处理数据 ===> 断电 ===> 内存空间和数据消失
- 内存分为
  - 栈：全局变量/局部变量
  - 堆: 对象
- 内存生命周期
  - 分配小内存空间，得到使用权
  - 存储数据，可以反复进行操作
  - 释放小内存空间
- 释放内存
  - 局部变量： 函数执行完自动释放
  - 对象： 成为垃圾对象 ==> 垃圾回收器回收

3. 变量

- 可变化的量，由变量名和变量值构成
- 每个变量都对应一个小内存块，变量名用来查找对应的内存，变量值内存中保存的数据

4. 三者关系

- 内存是用来存储数据的空间
- 变量是内存的标识

## 对象

1. 定义

- 多个数据的封装或用来报错多个数据的容器
- 一个对象代表现实中的一个事物

2. 为什么用对象

- 统一管理多个数据

3. 对象的组成

- 属性： 对象的属性，属性名（字符串）和属性值 组成
- 方法： 对象的方法（一种特别的属性 -- 属性值是函数），方法名和方法体

4. 访问内部数据

- `.属性名`
  一般情况均可使用，编码简单
- `[属性名]`
  1. 属性名包含字特殊字符时，可以使用中括号。
  2. 变量名不确定时，可以使用中括号

## 函数

1. 定义

-实现特定功能的 n 条语句的 可执行的 封装体

- 函数也是一个对象
- 函数中可以封装一些功能(代码)，在需要时可以执行这些功能(代码)
- 函数中可以保存一些代码，在需要的时候调用

- 优点
  - 提高代码复用
  - 便于阅读交流

2. 创建函数

- 构造函数
- 函数声明
- 表达式

- 封装到函数中的代码不会立即执行，会在函数调用时执行
- 函数调用时，函数中封装的代码会按照顺序执行

```js
// 构造函数方式创建函数
var fun = new Function();
// 函数声明创建函数
// function 函数名([形参1,形参2,,...]){
//    语句
// }
function fun2() {}
// 函数表达式
// var 函数名 = function([形参1,形参2,,...]){
//    语句
// }
var fun3 = function () {};

fun();
fun2();
fun3();
```

3. 函数参数

- 可以在函数的()中指定一个或多个形参(形式参数)
- 多个形参之间使用逗号隔开，声明的形参相当于在函数内部声明了对应的变量，但不赋值
- 调用函数是，可以在()中指定实参
- 实参将会赋值给函数中对应的形参，实参可以是任意类型
- 在 js 调用函数时，传递变量参数时，是值传递还是引用传递？
  - 值传递：传递的是变量的值，改变变量的值，不会影响到调用函数时的变量
  - 引用传递：传递的是变量的地址，改变变量的值，会影响到调用函数时的变量

```js
function sum(a, b) {
  console.log(a, b);
}

sum(1, 2);
```

4. 函数返回值

- 可以使用 return 来设置函数返回值
- 如果没有 return 语句，函数返回值为 undefined
- return 可以是任意数据类型
- return 之后的语句将不会执行

```js
function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
```

5. 立即执行函数（IIFE- Immediately-Invoked Function Expression）

- 函数定义完成后，立即执行
- 立即执行函数往往只会执行一次
- 优点
  - 隐藏实现
  - 不会污染外部（全局）命名空间
  - 用来编写 js 模块

```js
(function () {
  console.log('立即执行函数');
})();
```

6. 回调函数

- 定义
  你自己定义的，你没有调用，但最终会执行的函数

- 常见的回调函数
  - 定时器回调函数
  - ajax 回调函数
  - 生命周期回调函数

7. 函数中的 this

- 定义
  - 任何函数本质上都是通过某个对象来调用的，如果没有指定，就是 window
  - 所有函数都有一个变量 this，
  - this 的值是调用当前函数的对象
- 如何确认 this 的值
  - test（） // this 的值是 window
  - p.test() // this 的值是 p
  - new Test() // this 的值是 新创建的对象
  - test.call(p) // this 的值是 p
  - test.apply(p) // this 的值是 p
  - test.bind(p) // this 的值是 p

## 函数高级

### 原型（prototype）

1. 函数的 prototype

- 每个函数都有一个 prototype 属性，他默认指向一个 Object 对象（即 原型对象）
- 原型对象中有一个 constructor 属性，指向当前函数

2. 给原型对象添加属性（一般是方法）

- 函数的所有实例对象自动拥有原型中的属性（方法）

### 显式原型 与 隐式原型

1. 每个函数 function 都有一个 prototype，即 显式原型,默认指向一个空 Object 对象
2. 每个实例对象都有一个 `__proto__` 属性，即 隐式原型
3. 对象的隐式原型的值为其构造函数的显示原型的值
4. 函数的 prototype 属性：在定义函数时，自动添加的，默认值是一个空 Object 对象
5. 对象的`__proto__`属性：创建对象时，自动添加的，默认值是 其构造函数的 prototype 属性值
6. 可以直接操作显示原型

```js
function Fun() {} // 内部语句 this.__prototype = {}

let fn = new Fun(); //内部语句 this.__proto__ = Fn.prototype

console.log(Fun.prototype); // Fun {}

// 实例对象的隐式原型（__proto__）的值等于他的原型对象的prototype
console.log(fn.__proto__ === Fun.prototype); // true

Fn.prototype.test = function () {
  console.log('test');
};

fn.test(); // test
```

### 原型链（隐式原型链）

- 当我们访问一个对象的属性时，
  1. 先在自身属性中查找，找到返回
  2. 如果没有找到，再沿着`__proto__`这条链往上找，找到返回
  3. 如果最终还是没有找到，返回 undefined
- 作用：查找对象的属性（方法）
- Object的原型对象时原型链的尽头
